import java.util.NoSuchElementException;/** * A class that implements the ADT queue by using a resizable circular array. *  */public final class ArrayQueue<T> implements QueueInterface<T> {	private T[] queue; // Circular array of queue entries	private int frontIndex; // Index of front entry	// No need to keep track of the backIndex because...	// The back index can be calculated from (frontIndex + size) % queue.length	// Plus, there is only one place in the code where we really need the back index.	private int size;	private static final int DEFAULT_CAPACITY = 10;	/**	 * Constructs a queue with default initial array capacity	 */	public ArrayQueue() {		this(DEFAULT_CAPACITY);	}	/**	 * Constructs a queue with a specified initial array capacity	 * 	 * @param initialCapacity the desired initial array capacity	 */	@SuppressWarnings("unchecked")	public ArrayQueue(int initialCapacity) {		this.queue = (T[]) new Object[initialCapacity];		this.frontIndex = 0;		this.size = 0;	}		/**	 * Adds a new entry to the back of the queue.	 * 	 * @param newEntry the new entry to be added to the array.	 */	@Override	public void add(T newEntry) {	    ensureCapacity();	    queue[size] = newEntry;	    size++;	}	/**	 * A method that returns the first element in the array.	 */	@Override	public T peek() {		if (isEmpty())			throw new NoSuchElementException();		else			return queue[frontIndex];	}	/**	 * A method that removes the first element in the array	 * and returns it.	 */    @Override	public T remove() {        @SuppressWarnings("unchecked")        T tempQueue;	    tempQueue = queue[0];		for (int i = 0; i < size; i++) {		    queue[i] = queue[i+1];		}		size--;		return tempQueue;	}    /**     * A method returns true if the array is empty.     */	@Override	public boolean isEmpty() {		return size == 0;	}	/**	 * A method that clears the array of all elements.	 */	@Override	public void clear() {		if (!isEmpty()) { // deallocates only the used portion			for (int i = 0; i < size; i++) {				queue[(frontIndex + i) % queue.length] = null;			}		}		size = 0;	} // end clear	// Doubles the size of the array queue if it is full.	private void ensureCapacity() {		if (size == queue.length) {			T[] oldQueue = queue;			@SuppressWarnings("unchecked")			T[] tempQueue = (T[]) new Object[2 * size];			queue = tempQueue;			for (int i = 0; i < size; i++) {				tempQueue[i] = oldQueue[(frontIndex + i) % oldQueue.length];			}			frontIndex = 0;		}	}}